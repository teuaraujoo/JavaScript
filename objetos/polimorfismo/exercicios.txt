ğŸŸ¢ ExercÃ­cio 1 â€” Sistema de Pagamentos (polimorfismo clÃ¡ssico)
ğŸ“Œ Contexto real

Em um sistema de vendas, o cliente pode pagar de formas diferentes:

cartÃ£o de crÃ©dito

PIX

boleto

Cada forma de pagamento:

valida os dados de forma diferente

processa o pagamento de forma diferente

ğŸ¯ Seu desafio

Crie um sistema onde:

1ï¸âƒ£ Exista uma classe base Pagamento
2ï¸âƒ£ Ela tenha um mÃ©todo:

processar(valor)


3ï¸âƒ£ Crie classes filhas:

PagamentoCartao

PagamentoPix

PagamentoBoleto

4ï¸âƒ£ Cada classe filha deve reescrever (override) o mÃ©todo processar

ğŸ“Œ Todas devem poder ser usadas assim:

pagamento.processar(100);


ğŸ‘‰ Sem if para decidir o tipo de pagamento.

ğŸ§  O que estÃ¡ sendo treinado

heranÃ§a

sobrescrita de mÃ©todo

polimorfismo real

design limpo

ğŸŸ¡ ExercÃ­cio 2 â€” ValidaÃ§Ã£o polimÃ³rfica (mais sutil)
ğŸ“Œ Contexto real

VocÃª tem vÃ¡rios tipos de usuÃ¡rios:

Pessoa FÃ­sica

Pessoa JurÃ­dica

Administrador

Todos precisam ser validados, mas:

regras diferentes

mesma interface

ğŸ¯ Seu desafio

1ï¸âƒ£ Crie uma classe base Usuario com mÃ©todo:

validar()


2ï¸âƒ£ Crie classes:

PessoaFisica

PessoaJuridica

Admin

3ï¸âƒ£ Cada classe implementa sua prÃ³pria lÃ³gica de validaÃ§Ã£o

4ï¸âƒ£ Use assim:

usuarios.forEach(u => u.validar());


ğŸ“Œ Nenhum if (tipo === ...)

ğŸ§  O que estÃ¡ sendo treinado

polimorfismo em listas

substituiÃ§Ã£o de comportamento

cÃ³digo aberto para extensÃ£o

ğŸ”´ ExercÃ­cio 3 â€” Desafio: Sistema de NotificaÃ§Ãµes
ğŸ“Œ Contexto real

Um sistema pode notificar usuÃ¡rios por:

Email

SMS

Push Notification

Todos notificam, mas cada um:

usa um meio diferente

tem regras prÃ³prias

ğŸ¯ Seu desafio

1ï¸âƒ£ Crie uma classe base Notificacao com mÃ©todo:

enviar(mensagem)


2ï¸âƒ£ Crie:

EmailNotificacao

SmsNotificacao

PushNotificacao

3ï¸âƒ£ Todas devem funcionar assim:

notificacao.enviar("Pedido confirmado");


4ï¸âƒ£ Crie uma funÃ§Ã£o:

enviarNotificacao(notificacao)


Que funcione com qualquer tipo de notificaÃ§Ã£o